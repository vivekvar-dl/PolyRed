<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced 3D Model Optimizer</title>
    <style>
        :root {
            --primary-color: #2b7a2f;
            --primary-hover: #1e5420;
            --background-color: #f5f5f5;
            --panel-background: rgba(255, 255, 255, 0.95);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--background-color);
            color: #333;
            line-height: 1.6;
        }

        .container {
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            min-height: 100vh;
        }

        .sidebar {
            padding: 20px;
            background: var(--panel-background);
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
            overflow-y: auto;
            max-height: 100vh;
        }

        .viewer {
            position: relative;
            grid-column: 2;
        }

        .right-panel {
            padding: 20px;
            background: var(--panel-background);
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 10;
            overflow-y: auto;
        }

        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.03);
        }

        .control-group h3 {
            margin-bottom: 10px;
            color: #1a1a1a;
            font-size: 1.1em;
        }

        .file-input-wrapper {
            position: relative;
            margin-bottom: 15px;
        }

        .file-input-wrapper input[type="file"] {
            display: none;
        }

        .file-input-wrapper label {
            display: block;
            padding: 10px 15px;
            background: var(--primary-color);
            color: white;
            text-align: center;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .file-input-wrapper label:hover {
            background: var(--primary-hover);
        }

        .optimization-controls {
            display: grid;
            gap: 15px;
        }

        .slider-wrapper {
            margin: 10px 0;
        }

        .slider-wrapper label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 5px 0;
        }

        .checkbox-wrapper input[type="checkbox"] {
            width: 16px;
            height: 16px;
        }

        button {
            padding: 10px 15px;
            background: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: 500;
            width: 100%;
            margin: 5px 0;
        }

        button:hover {
            background: var(--primary-hover);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .stats-panel {
            margin-bottom: 20px;
        }

        .stats-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .stats-value {
            font-weight: 600;
        }

        .optimization-info {
            font-size: 0.85em;
            color: #666;
            margin-top: 5px;
        }

        #loadingOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-content {
            background: white;
            padding: 20px 40px;
            border-radius: 8px;
            text-align: center;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .tooltip {
            position: relative;
            display: inline-block;
            margin-left: 5px;
            cursor: help;
        }

        .tooltip::after {
            content: "?";
            display: inline-block;
            width: 16px;
            height: 16px;
            background: #666;
            color: white;
            border-radius: 50%;
            text-align: center;
            font-size: 12px;
            line-height: 16px;
        }

        .tooltip:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="control-group">
                <h3>Upload Model</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="fileInput" accept=".obj,.glb,.gltf,.fbx" aria-label="Choose 3D model file">
                    <label for="fileInput">Choose File</label>
                </div>
                <div id="fileName" style="font-size: 0.9em; color: #666; word-break: break-all;"></div>
            </div>

            <div class="control-group">
                <h3>Optimization Settings</h3>
                <div class="optimization-controls">
                    <div class="slider-wrapper">
                        <label for="ratioSlider">Target Ratio: <span id="ratioValue">50</span>%
                            <span class="tooltip" data-tooltip="Target percentage of triangles to keep"></span>
                        </label>
                        <input type="range" id="ratioSlider" min="1" max="100" value="50" aria-label="Optimization ratio">
                    </div>

                    <div class="slider-wrapper">
                        <label for="errorSlider">Error Threshold: <span id="errorValue">0.01</span>
                            <span class="tooltip" data-tooltip="Maximum allowed geometric error"></span>
                        </label>
                        <input type="range" id="errorSlider" min="0" max="100" value="1" step="0.1" aria-label="Error threshold">
                    </div>

                    <div class="slider-wrapper">
                        <label for="normalWeight">Normal Weight: <span id="normalWeightValue">0.5</span>
                            <span class="tooltip" data-tooltip="Weight for preserving normal vectors"></span>
                        </label>
                        <input type="range" id="normalWeight" min="0" max="100" value="50" aria-label="Normal weight">
                    </div>

                    <div class="slider-wrapper">
                        <label for="boundaryWeight">Boundary Weight: <span id="boundaryWeightValue">2.0</span>
                            <span class="tooltip" data-tooltip="Weight for preserving mesh boundaries"></span>
                        </label>
                        <input type="range" id="boundaryWeight" min="0" max="300" value="200" aria-label="Boundary weight">
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="lockBoundary" checked>
                        <label for="lockBoundary">Lock Boundary Vertices
                            <span class="tooltip" data-tooltip="Prevent modification of mesh boundaries"></span>
                        </label>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="preserveTopology" checked>
                        <label for="preserveTopology">Preserve Topology
                            <span class="tooltip" data-tooltip="Maintain mesh connectivity and structure"></span>
                        </label>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="optimizeVertexCache" checked>
                        <label for="optimizeVertexCache">Optimize Vertex Cache
                            <span class="tooltip" data-tooltip="Improve rendering performance"></span>
                        </label>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="weldVertices">
                        <label for="weldVertices">Weld Vertices
                            <span class="tooltip" data-tooltip="Merge nearby vertices"></span>
                        </label>
                    </div>

                    <button id="optimizeBtn" disabled>Optimize Model</button>
                    <button id="resetBtn" disabled>Reset Model</button>
                    <button id="downloadBtn" disabled>Download Optimized Model</button>
                </div>
            </div>
        </div>

        <div class="viewer">
            <!-- 3D viewer will be inserted here -->
        </div>

        <div class="right-panel">
            <div class="control-group">
                <h3>Model Statistics</h3>
                <div class="stats-panel">
                    <div class="stats-item">
                        <span>Vertices:</span>
                        <span id="vertexCount" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span>Triangles:</span>
                        <span id="triangleCount" class="stats-value">0</span>
                    </div>
                    <div class="stats-item">
                        <span>File Size:</span>
                        <span id="fileSize" class="stats-value">0 KB</span>
                    </div>
                    <div class="stats-item">
                        <span>Reduction:</span>
                        <span id="reduction" class="stats-value">0%</span>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>Advanced Settings</h3>
                <div class="optimization-controls">
                    <div class="slider-wrapper">
                        <label for="vertexCacheSize">Vertex Cache Size: <span id="vertexCacheSizeValue">32</span>
                            <span class="tooltip" data-tooltip="Size of vertex cache for optimization"></span>
                        </label>
                        <input type="range" id="vertexCacheSize" min="8" max="64" value="32" aria-label="Vertex cache size">
                    </div>

                    <div class="slider-wrapper">
                        <label for="weldThreshold">Weld Threshold: <span id="weldThresholdValue">0.0001</span>
                            <span class="tooltip" data-tooltip="Distance threshold for vertex welding"></span>
                        </label>
                        <input type="range" id="weldThreshold" min="0" max="100" value="1" step="0.1" aria-label="Weld threshold">
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="quantizeVertices">
                        <label for="quantizeVertices">Quantize Vertices
                            <span class="tooltip" data-tooltip="Reduce vertex precision for compression"></span>
                        </label>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="stripify">
                        <label for="stripify">Generate Triangle Strips
                            <span class="tooltip" data-tooltip="Convert triangles to strips for better performance"></span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="control-group">
                <h3>Export Settings</h3>
                <div class="optimization-controls">
                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="compressNormals" checked>
                        <label for="compressNormals">Compress Normals
                            <span class="tooltip" data-tooltip="Use octahedral normal compression"></span>
                        </label>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="compressUVs" checked>
                        <label for="compressUVs">Compress UVs
                            <span class="tooltip" data-tooltip="Quantize texture coordinates"></span>
                        </label>
                    </div>

                    <div class="checkbox-wrapper">
                        <input type="checkbox" id="generateLODs">
                        <label for="generateLODs">Generate LODs
                            <span class="tooltip" data-tooltip="Create multiple detail levels"></span>
                        </label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="loadingOverlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div id="loadingText">Processing...</div>
        </div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.157.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.157.0/examples/jsm/"
            }
        }
    </script>

    <!-- Load MeshoptSimplifier and FBX loader -->
    <script src="./js/meshopt_simplifier.js"></script>

    <script type="module">
        // Import statements will go here
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import { OBJExporter } from 'three/addons/exporters/OBJExporter.js';
        import { GLTFExporter } from 'three/addons/exporters/GLTFExporter.js';
        import { mergeVertices } from 'three/addons/utils/BufferGeometryUtils.js';

        // Main class implementation will go here
        class AdvancedModelOptimizer {
            constructor() {
                // Initialize properties
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.setupScene();
                this.setupLights();
                this.setupControls();
                this.setupEventListeners();
                
                this.originalModel = null;
                this.currentModel = null;
                this.isProcessing = false;
                this.settings = {
                    normalWeight: 0.5,
                    boundaryWeight: 2.0,
                    lockBoundary: true,
                    preserveTopology: true,
                    optimizeVertexCache: true,
                    weldVertices: false,
                    vertexCacheSize: 32,
                    weldThreshold: 0.0001,
                    quantizeVertices: false,
                    stripify: false,
                    compressNormals: true,
                    compressUVs: true,
                    generateLODs: false
                };

                // Start animation loop
                this.animate();
            }

            setupScene() {
                this.scene.background = new THREE.Color(0xf5f5f5);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.setSize(window.innerWidth - 600, window.innerHeight); // Adjust for sidebars
                document.querySelector('.viewer').appendChild(this.renderer.domElement);
                
                // Add grid helper
                const size = 20;
                const divisions = 20;
                const gridHelper = new THREE.GridHelper(size, divisions, 0x666666, 0x999999);
                this.scene.add(gridHelper);

                // Add axes helper
                const axesHelper = new THREE.AxesHelper(5);
                this.scene.add(axesHelper);

                // Add a ground plane for better visibility
                const groundGeometry = new THREE.PlaneGeometry(size, size);
                const groundMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 1.0,
                    metalness: 0.0,
                    transparent: true,
                    opacity: 0.5
                });
                const ground = new THREE.Mesh(groundGeometry, groundMaterial);
                ground.rotation.x = -Math.PI / 2;
                ground.position.y = -0.01; // Slightly below the grid
                ground.receiveShadow = true;
                this.scene.add(ground);
                
                // Set initial camera position further back for better visibility
                this.camera.position.set(5, 5, 10);
                this.camera.lookAt(0, 0, 0);

                // Enable shadows
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            }

            setupLights() {
                // Add stronger lighting setup
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);

                // Main directional light with shadow
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
                mainLight.position.set(5, 10, 5);
                mainLight.castShadow = true;
                mainLight.shadow.mapSize.width = 1024;
                mainLight.shadow.mapSize.height = 1024;
                mainLight.shadow.camera.near = 0.1;
                mainLight.shadow.camera.far = 100;
                mainLight.shadow.camera.left = -10;
                mainLight.shadow.camera.right = 10;
                mainLight.shadow.camera.top = 10;
                mainLight.shadow.camera.bottom = -10;
                this.scene.add(mainLight);

                // Fill lights
                const fillLight1 = new THREE.DirectionalLight(0xffffff, 0.4);
                const fillLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
                fillLight1.position.set(-5, 2, -5);
                fillLight2.position.set(5, -2, -5);
                this.scene.add(fillLight1);
                this.scene.add(fillLight2);
            }

            setupControls() {
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.screenSpacePanning = true;
                this.controls.minDistance = 0.1;
                this.controls.maxDistance = 50;
            }

            setupEventListeners() {
                // File input handling
                const fileInput = document.getElementById('fileInput');
                fileInput.addEventListener('change', (e) => this.handleFileSelect(e));

                // UI controls
                document.getElementById('ratioSlider').addEventListener('input', (e) => {
                    document.getElementById('ratioValue').textContent = e.target.value;
                });

                document.getElementById('errorSlider').addEventListener('input', (e) => {
                    document.getElementById('errorValue').textContent = (e.target.value / 100).toFixed(3);
                });

                document.getElementById('normalWeight').addEventListener('input', (e) => {
                    document.getElementById('normalWeightValue').textContent = (e.target.value / 100).toFixed(2);
                    this.settings.normalWeight = e.target.value / 100;
                });

                document.getElementById('boundaryWeight').addEventListener('input', (e) => {
                    document.getElementById('boundaryWeightValue').textContent = (e.target.value / 100).toFixed(2);
                    this.settings.boundaryWeight = e.target.value / 100;
                });

                document.getElementById('vertexCacheSize').addEventListener('input', (e) => {
                    document.getElementById('vertexCacheSizeValue').textContent = e.target.value;
                    this.settings.vertexCacheSize = parseInt(e.target.value);
                });

                document.getElementById('weldThreshold').addEventListener('input', (e) => {
                    document.getElementById('weldThresholdValue').textContent = (e.target.value / 10000).toFixed(4);
                    this.settings.weldThreshold = e.target.value / 10000;
                });

                // Checkboxes
                document.getElementById('lockBoundary').addEventListener('change', (e) => {
                    this.settings.lockBoundary = e.target.checked;
                });

                document.getElementById('preserveTopology').addEventListener('change', (e) => {
                    this.settings.preserveTopology = e.target.checked;
                });

                document.getElementById('optimizeVertexCache').addEventListener('change', (e) => {
                    this.settings.optimizeVertexCache = e.target.checked;
                });

                document.getElementById('weldVertices').addEventListener('change', (e) => {
                    this.settings.weldVertices = e.target.checked;
                });

                document.getElementById('quantizeVertices').addEventListener('change', (e) => {
                    this.settings.quantizeVertices = e.target.checked;
                });

                document.getElementById('stripify').addEventListener('change', (e) => {
                    this.settings.stripify = e.target.checked;
                });

                document.getElementById('compressNormals').addEventListener('change', (e) => {
                    this.settings.compressNormals = e.target.checked;
                });

                document.getElementById('compressUVs').addEventListener('change', (e) => {
                    this.settings.compressUVs = e.target.checked;
                });

                document.getElementById('generateLODs').addEventListener('change', (e) => {
                    this.settings.generateLODs = e.target.checked;
                });

                // Buttons
                document.getElementById('optimizeBtn').addEventListener('click', () => this.optimizeModel());
                document.getElementById('resetBtn').addEventListener('click', () => this.resetModel());
                document.getElementById('downloadBtn').addEventListener('click', () => this.downloadModel());

                // Window resize handling
                window.addEventListener('resize', () => this.handleResize());
            }

            handleResize() {
                this.camera.aspect = (window.innerWidth - 600) / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth - 600, window.innerHeight);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.originalFileSize = file.size;
                document.getElementById('fileName').textContent = file.name;
                this.setLoading(true);

                try {
                    const buffer = await file.arrayBuffer();
                    const extension = file.name.split('.').pop().toLowerCase();
                    
                    console.log('Loading file:', {
                        name: file.name,
                        size: file.size,
                        type: file.type,
                        extension: extension
                    });

                    let object;
                    if (extension === 'fbx') {
                        const loader = new FBXLoader();
                        const blob = new Blob([buffer], { type: 'application/octet-stream' });
                        const url = URL.createObjectURL(blob);
                        object = await new Promise((resolve, reject) => {
                            loader.load(url, 
                                (result) => {
                                    console.log('FBX loaded successfully:', result);
                                    resolve(result);
                                },
                                (xhr) => {
                                    console.log(`${(xhr.loaded / xhr.total * 100)}% loaded`);
                                },
                                (error) => {
                                    console.error('Error loading FBX:', error);
                                    reject(new Error('Failed to load FBX file: ' + error.message));
                                }
                            );
                        });
                        URL.revokeObjectURL(url);
                    } else if (extension === 'obj') {
                        const loader = new OBJLoader();
                        const text = new TextDecoder().decode(buffer);
                        object = loader.parse(text);
                        console.log('OBJ loaded successfully:', object);
                    } else if (extension === 'glb' || extension === 'gltf') {
                        const loader = new GLTFLoader();
                        const result = await new Promise((resolve, reject) => {
                            loader.parse(buffer, '', 
                                (gltf) => {
                                    console.log('GLTF/GLB loaded successfully:', gltf);
                                    resolve(gltf);
                                },
                                (error) => {
                                    console.error('Error loading GLTF/GLB:', error);
                                    reject(new Error('Failed to load GLTF/GLB file: ' + error.message));
                                }
                            );
                        });
                        object = result.scene;
                    } else {
                        throw new Error(`Unsupported file format: ${extension}`);
                    }

                    // Check if object is valid
                    if (!object) {
                        throw new Error('Loaded object is null or undefined');
                    }

                    // Log object details before loading
                    console.log('Object before loading:', {
                        type: object.type,
                        children: object.children ? object.children.length : 0,
                        isObject3D: object instanceof THREE.Object3D,
                        position: object.position,
                        scale: object.scale
                    });

                    await this.loadModel(object);
                    this.enableControls();
                } catch (error) {
                    console.error('Error loading file:', error);
                    this.showError(`Failed to load model: ${error.message}`);
                } finally {
                    this.setLoading(false);
                }
            }

            async loadModel(object) {
                try {
                    console.log('Starting model load...');
                    
                    // Clear existing model
                    if (this.currentModel) {
                        this.scene.remove(this.currentModel);
                        this.currentModel.traverse((child) => {
                            if (child.geometry) child.geometry.dispose();
                            if (child.material) {
                                if (Array.isArray(child.material)) {
                                    child.material.forEach(m => m.dispose());
                                } else {
                                    child.material.dispose();
                                }
                            }
                        });
                    }

                    // Debug info
                    let meshCount = 0;
                    let vertexCount = 0;
                    let triangleCount = 0;

                    // Enable shadows and process materials
                    object.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            vertexCount += child.geometry.attributes.position.count;
                            triangleCount += child.geometry.index ? child.geometry.index.count / 3 : 0;

                            child.castShadow = true;
                            child.receiveShadow = true;
                            
                            // Convert materials to MeshStandardMaterial with better defaults
                            if (child.material) {
                                const oldMaterial = child.material;
                                const newMaterial = new THREE.MeshStandardMaterial({
                                    color: oldMaterial.color || 0x808080,
                                    metalness: 0.2,
                                    roughness: 0.8,
                                    map: oldMaterial.map || null,
                                    normalMap: oldMaterial.normalMap || null,
                                    aoMap: oldMaterial.aoMap || null,
                                    transparent: oldMaterial.transparent || false,
                                    opacity: oldMaterial.opacity !== undefined ? oldMaterial.opacity : 1.0,
                                    side: THREE.DoubleSide  // Render both sides of faces
                                });
                                
                                if (oldMaterial.emissive) {
                                    newMaterial.emissive = oldMaterial.emissive;
                                    newMaterial.emissiveIntensity = oldMaterial.emissiveIntensity || 1.0;
                                    newMaterial.emissiveMap = oldMaterial.emissiveMap || null;
                                }
                                
                                child.material = newMaterial;
                            }

                            // Ensure geometry is properly indexed
                            if (!child.geometry.index) {
                                console.log('Converting non-indexed geometry to indexed');
                                child.geometry = mergeVertices(child.geometry.clone());
                            }

                            // Compute normals if they don't exist
                            if (!child.geometry.attributes.normal) {
                                console.log('Computing missing normals');
                                child.geometry.computeVertexNormals();
                            }

                            // Ensure bounds are computed
                            child.geometry.computeBoundingSphere();
                            child.geometry.computeBoundingBox();
                        }
                    });

                    console.log('Model statistics:', {
                        meshCount,
                        vertexCount,
                        triangleCount
                    });

                    // Store and display new model
                    this.originalModel = object.clone();
                    this.currentModel = object;

                    // Get bounding box before adding to scene
                    const box = new THREE.Box3().setFromObject(object);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());

                    console.log('Model bounds:', {
                        size: size.toArray(),
                        center: center.toArray()
                    });

                    // Reset position and apply scale
                    object.position.copy(new THREE.Vector3(0, 0, 0));
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 5 / maxDim;
                    object.scale.setScalar(scale);

                    // Add to scene
                    this.scene.add(this.currentModel);

                    // Position camera based on bounding box
                    const distance = Math.max(size.x, size.y, size.z) * 2;
                    this.camera.position.set(distance, distance/2, distance);
                    this.controls.target.set(0, 0, 0);
                    this.controls.update();

                    // Update statistics
                    this.updateStats();
                    
                    console.log('Model loaded successfully');
                    
                    // Show success message with stats
                    this.showMessage(`Model loaded: ${meshCount} meshes, ${vertexCount.toLocaleString()} vertices`);
                } catch (error) {
                    console.error('Error in loadModel:', error);
                    this.showError(`Failed to load model: ${error.message}`);
                    throw error;
                }
            }

            setLoading(loading) {
                document.getElementById('loadingOverlay').style.display = loading ? 'flex' : 'none';
            }

            showError(message) {
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #ff4444;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 4px;
                    z-index: 1000;
                `;
                errorDiv.textContent = message;
                document.body.appendChild(errorDiv);
                setTimeout(() => errorDiv.remove(), 5000);
            }

            showMessage(message) {
                const messageDiv = document.createElement('div');
                messageDiv.style.cssText = `
                    position: fixed;
                    top: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: #44ff44;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 4px;
                    z-index: 1000;
                `;
                messageDiv.textContent = message;
                document.body.appendChild(messageDiv);
                setTimeout(() => messageDiv.remove(), 5000);
            }

            enableControls() {
                document.getElementById('optimizeBtn').disabled = false;
                document.getElementById('resetBtn').disabled = false;
                document.getElementById('downloadBtn').disabled = false;
            }

            updateStats() {
                let vertexCount = 0;
                let triangleCount = 0;

                this.currentModel.traverse((child) => {
                    if (child.geometry) {
                        vertexCount += child.geometry.attributes.position.count;
                        triangleCount += child.geometry.index ? 
                            child.geometry.index.count / 3 : 
                            child.geometry.attributes.position.count / 3;
                    }
                });

                document.getElementById('vertexCount').textContent = vertexCount.toLocaleString();
                document.getElementById('triangleCount').textContent = Math.floor(triangleCount).toLocaleString();
                document.getElementById('fileSize').textContent = this.formatFileSize(this.originalFileSize || 0);

                // Calculate reduction if we have both models
                if (this.originalModel && this.currentModel !== this.originalModel) {
                    let originalTriCount = 0;
                    this.originalModel.traverse((child) => {
                        if (child.geometry) {
                            originalTriCount += child.geometry.index ? 
                                child.geometry.index.count / 3 : 
                                child.geometry.attributes.position.count / 3;
                        }
                    });
                    const reduction = ((originalTriCount - triangleCount) / originalTriCount * 100).toFixed(1);
                    document.getElementById('reduction').textContent = `${reduction}%`;
                } else {
                    document.getElementById('reduction').textContent = '0%';
                }
            }

            formatFileSize(bytes) {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }

            async optimizeModel() {
                if (!this.currentModel || this.isProcessing) {
                    return;
                }

                try {
                    this.isProcessing = true;
                    this.setLoading(true);
                    document.getElementById('loadingText').textContent = 'Optimizing model...';

                    // Get reduction ratio from slider (1-100%)
                    const targetRatio = parseInt(document.getElementById('ratioSlider').value) / 100;
                    const errorThreshold = parseFloat(document.getElementById('errorSlider').value) / 100;

                    console.log('Starting optimization with:', {
                        targetRatio,
                        errorThreshold,
                        settings: this.settings
                    });

                    let totalVerticesBefore = 0;
                    let totalVerticesAfter = 0;
                    let totalTrianglesBefore = 0;
                    let totalTrianglesAfter = 0;
                    let optimizedCount = 0;
                    let totalMeshes = 0;

                    // First pass: count total vertices and triangles
                    this.currentModel.traverse((child) => {
                        if (child.isMesh && child.geometry) {
                            totalMeshes++;
                            totalVerticesBefore += child.geometry.attributes.position.count;
                            totalTrianglesBefore += child.geometry.index ? child.geometry.index.count / 3 : 0;
                        }
                    });

                    // Calculate target counts for the entire model
                    const targetTriangles = Math.max(Math.ceil(totalTrianglesBefore * targetRatio), 4);
                    console.log('Target triangles:', targetTriangles);

                    // Process each mesh
                    const meshes = [];
                    this.currentModel.traverse((child) => {
                        if (child.isMesh && child.geometry) {
                            meshes.push(child);
                        }
                    });

                    // Sort meshes by triangle count (largest first)
                    meshes.sort((a, b) => {
                        const countA = a.geometry.index ? a.geometry.index.count / 3 : 0;
                        const countB = b.geometry.index ? b.geometry.index.count / 3 : 0;
                        return countB - countA;
                    });

                    // Process each mesh
                    for (const mesh of meshes) {
                        try {
                            const geometry = mesh.geometry;
                            const triangleCount = geometry.index ? geometry.index.count / 3 : 0;
                            
                            // Skip small meshes
                            if (triangleCount < 100) {
                                console.log('Skipping small mesh:', triangleCount, 'triangles');
                                continue;
                            }

                            // Calculate individual mesh target ratio based on its size
                            const meshRatio = triangleCount / totalTrianglesBefore;
                            const meshTargetTriangles = Math.max(
                                Math.ceil(triangleCount * targetRatio),
                                Math.ceil(targetTriangles * meshRatio)
                            );

                            console.log('Processing mesh:', {
                                originalTriangles: triangleCount,
                                targetTriangles: meshTargetTriangles,
                                ratio: meshTargetTriangles / triangleCount
                            });

                            // Prepare arrays for simplification
                            const positions = geometry.attributes.position;
                            const indices = geometry.index;

                            if (!positions || !indices) {
                                console.log('Skipping mesh without required attributes');
                                continue;
                            }

                            const positionsArray = new Float32Array(positions.array);
                            const indicesArray = new Uint32Array(indices.array);

                            // Set simplification flags
                            const flags = [];
                            if (this.settings.lockBoundary) flags.push('LockBorder');
                            if (this.settings.preserveTopology) flags.push('Sparse');

                            // Perform simplification
                            const result = MeshoptSimplifier.simplify(
                                indicesArray,
                                positionsArray,
                                3,
                                meshTargetTriangles * 3,
                                errorThreshold,
                                flags
                            );

                            if (result && Array.isArray(result) && result.length === 2) {
                                const [newIndices, error] = result;
                                
                                // Create new geometry
                                const newGeometry = new THREE.BufferGeometry();
                                newGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positionsArray, 3));
                                newGeometry.setIndex(new THREE.Uint32BufferAttribute(newIndices, 1));

                                // Transfer other attributes
                                for (const key in geometry.attributes) {
                                    if (key !== 'position') {
                                        newGeometry.setAttribute(key, geometry.attributes[key].clone());
                                    }
                                }

                                // Compute normals
                                newGeometry.computeVertexNormals();

                                // Update mesh
                                geometry.dispose();
                                mesh.geometry = newGeometry;

                                optimizedCount++;
                                totalVerticesAfter += newGeometry.attributes.position.count;
                                totalTrianglesAfter += newIndices.length / 3;

                                console.log('Mesh optimized:', {
                                    beforeTriangles: triangleCount,
                                    afterTriangles: newIndices.length / 3,
                                    reduction: ((triangleCount - newIndices.length / 3) / triangleCount * 100).toFixed(2) + '%',
                                    error: error
                                });
                            }
                        } catch (error) {
                            console.error('Error optimizing mesh:', error);
                        }
                    }

                    // Update statistics
                    this.updateStats();

                    const reductionPercent = ((totalTrianglesBefore - totalTrianglesAfter) / totalTrianglesBefore * 100).toFixed(2);
                    this.showMessage(
                        `Optimization complete:\n` +
                        `Triangles: ${totalTrianglesBefore.toLocaleString()} → ${totalTrianglesAfter.toLocaleString()}\n` +
                        `Reduction: ${reductionPercent}%\n` +
                        `Optimized ${optimizedCount} of ${totalMeshes} meshes`
                    );

                } catch (error) {
                    console.error('Optimization error:', error);
                    this.showError(`Optimization failed: ${error.message}`);
                } finally {
                    this.isProcessing = false;
                    this.setLoading(false);
                }
            }

            resetModel() {
                if (!this.originalModel) return;

                this.scene.remove(this.currentModel);
                this.currentModel = this.originalModel.clone();
                this.scene.add(this.currentModel);
                this.updateStats();
            }

            async downloadModel(retryCount = 0) {
                if (!this.currentModel) {
                    this.showError('No model to download');
                    return;
                }

                // Prevent infinite recursion
                if (retryCount > 2) {
                    this.showError('Could not achieve file size reduction after multiple attempts');
                    return;
                }

                try {
                    this.setLoading(true);
                    const originalFileName = document.getElementById('fileName').textContent;
                    const extension = originalFileName.split('.').pop().toLowerCase();
                    const baseName = originalFileName.split('.')[0];
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');

                    // Adjust optimization settings based on retry count
                    const compressionSettings = {
                        0: { // First attempt - moderate compression
                            maxTextureSize: 1024,
                            quantizePosition: 12,
                            quantizeNormal: 8,
                            quantizeTexcoord: 10
                        },
                        1: { // Second attempt - aggressive compression
                            maxTextureSize: 512,
                            quantizePosition: 11,
                            quantizeNormal: 7,
                            quantizeTexcoord: 8
                        },
                        2: { // Final attempt - maximum compression
                            maxTextureSize: 256,
                            quantizePosition: 10,
                            quantizeNormal: 6,
                            quantizeTexcoord: 6
                        }
                    }[retryCount];

                    // Pre-process model for export
                    this.currentModel.traverse((child) => {
                        if (child.isMesh) {
                            // Optimize materials and textures
                            if (child.material) {
                                const material = child.material;
                                const textures = [
                                    material.map,
                                    material.normalMap,
                                    material.aoMap,
                                    material.emissiveMap
                                ].filter(tex => tex);

                                textures.forEach(texture => {
                                    if (texture && texture.image) {
                                        const canvas = document.createElement('canvas');
                                        const ctx = canvas.getContext('2d');
                                        const maxSize = compressionSettings.maxTextureSize;

                                        let width = texture.image.width;
                                        let height = texture.image.height;

                                        if (width > maxSize || height > maxSize) {
                                            if (width > height) {
                                                height *= maxSize / width;
                                                width = maxSize;
                                            } else {
                                                width *= maxSize / height;
                                                height = maxSize;
                                            }
                                        }

                                        canvas.width = width;
                                        canvas.height = height;
                                        ctx.drawImage(texture.image, 0, 0, width, height);
                                        texture.image = canvas;
                                        texture.needsUpdate = true;
                                        texture.minFilter = THREE.LinearFilter;
                                        texture.magFilter = THREE.LinearFilter;
                                        texture.generateMipmaps = false;
                                    }
                                });

                                // Simplify material properties
                                material.flatShading = true;
                                material.roughness = 1.0;
                                material.metalness = 0.0;
                            }

                            // Optimize geometry
                            if (child.geometry) {
                                // Remove non-essential attributes
                                const geometry = child.geometry;
                                const essentialAttributes = ['position', 'normal', 'uv'];
                                for (const key in geometry.attributes) {
                                    if (!essentialAttributes.includes(key)) {
                                        geometry.deleteAttribute(key);
                                    }
                                }

                                // Normalize normals
                                if (geometry.attributes.normal) {
                                    const normals = geometry.attributes.normal;
                                    for (let i = 0; i < normals.count; i++) {
                                        const x = normals.getX(i);
                                        const y = normals.getY(i);
                                        const z = normals.getZ(i);
                                        const length = Math.sqrt(x * x + y * y + z * z);
                                        if (length > 0) {
                                            normals.setXYZ(i, x/length, y/length, z/length);
                                        }
                                    }
                                    normals.needsUpdate = true;
                                    normals.normalized = true;
                                }

                                // Merge vertices with a larger threshold on retry attempts
                                const mergeThreshold = 0.0001 * Math.pow(10, retryCount);
                                geometry.merge = mergeVertices(geometry, mergeThreshold);
                            }
                        }
                    });

                    // Export settings
                    const exportSettings = {
                        binary: true,
                        embedImages: true,
                        includeCustomExtensions: false,
                        forceIndices: true,
                        truncateDrawRange: true,
                        onlyVisible: true,
                        precision: 6 - retryCount, // Reduce precision on retries
                        maxTextureSize: compressionSettings.maxTextureSize,
                        animations: [],  // Exclude animations to reduce size
                        meshQuantization: true,
                        meshOptCompression: true,
                        dracoCompression: {
                            enable: true,
                            quantizePosition: compressionSettings.quantizePosition,
                            quantizeNormal: compressionSettings.quantizeNormal,
                            quantizeTexcoord: compressionSettings.quantizeTexcoord,
                            quantizeColor: 8
                        }
                    };

                    let result;
                    let exportExtension;

                    if (extension === 'fbx' || extension === 'glb' || extension === 'gltf') {
                        const exporter = new GLTFExporter();
                        result = await new Promise((resolve, reject) => {
                            exporter.parse(
                                this.currentModel,
                                (gltf) => resolve(gltf),
                                (error) => reject(error),
                                exportSettings
                            );
                        });
                        exportExtension = 'glb';
                    } else if (extension === 'obj') {
                        const exporter = new OBJExporter();
                        result = exporter.parse(this.currentModel);
                        exportExtension = 'obj';
                    }

                    const blob = new Blob(
                        [result],
                        { type: exportExtension === 'obj' ? 'text/plain' : 'application/octet-stream' }
                    );

                    const originalSize = this.originalFileSize || 0;
                    const newSize = blob.size;

                    if (newSize >= originalSize && retryCount < 2) {
                        console.log(`Retry ${retryCount + 1}: File size not reduced (${this.formatFileSize(newSize)} >= ${this.formatFileSize(originalSize)})`);
                        return await this.downloadModel(retryCount + 1);
                    }

                    // Get final statistics
                    let totalVertices = 0;
                    let totalTriangles = 0;
                    this.currentModel.traverse((child) => {
                        if (child.isMesh) {
                            const geometry = child.geometry;
                            totalVertices += geometry.attributes.position.count;
                            totalTriangles += geometry.index ? geometry.index.count / 3 : 0;
                        }
                    });

                    // Create download link
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `${baseName}_optimized_${timestamp}.${exportExtension}`;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);

                    const reduction = ((originalSize - newSize) / originalSize * 100).toFixed(2);
                    this.showMessage(`Optimization complete:
                        Original size: ${this.formatFileSize(originalSize)}
                        New size: ${this.formatFileSize(newSize)}
                        Size reduction: ${reduction}%
                        Total vertices: ${totalVertices}
                        Total triangles: ${totalTriangles}
                        Compression level: ${retryCount + 1}/3`);

                } catch (error) {
                    console.error('Export error:', error);
                    this.showError('Failed to export model: ' + error.message);
                } finally {
                    this.setLoading(false);
                }
            }
        }

        // Initialize the application
        const modelOptimizer = new AdvancedModelOptimizer();
        window.modelOptimizer = modelOptimizer; // Make it accessible for debugging
    </script>
</body>
</html> 
